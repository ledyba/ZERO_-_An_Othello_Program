  public static double run(boolean last,int depth , int turn ,int turn_count ,int open_value , double alpha, double beta){
    if(depth <= 0 || turn_count > 60){
      return eval(open_value,turn,p);
    }else{
      int[] bkp = (int[])p.clone(); //局面のバックアップ
      int move_count = 0;
      double s = 0;
      for (int x = 1; x <= 8; x++) {
        for (int y = 1; y <= 8; y++) {
            if(pto.main(x,y,turn)){
              s = -1 * run(true,depth - 1, turn * -1, turn_count + 1,
                           -1 * (open_value+open_value(bkp,turn)), -beta, -alpha);
              count[depth][0]++;
              move_count++;
              if(depth == master_depth){
                System.out.println("x:"+x+" y:"+y+" eval:"+s);
              }
              p = (int[])bkp.clone(); //戻す
              if(s >= beta){
                count[depth][1]++;
                return s;
              }else{
                if (s > alpha) {
                  if (depth == master_depth) {
                    move[0] = x;
                    move[1] = y;
                    best_move_value = s;
                  }
                  alpha = s;
                }
              }
            }
        }
      }
      if(move_count == 0){//パス処理
        if(last == false){//前回もダメ＝ここは葉っぱ
          //両者打てないというのは完封の可能性もある．
          int[] piece_amount = new int[2];
          //[0]:自分 [1]:相手
          for (int x = 1; x <= 8; x++) {
            for (int y = 1; y <= 8; y++) {
              if(p[10*x+y] == turn){
                piece_amount[0]++;
              }else if(p[10*x+y] == turn * -1){
                piece_amount[1]++;
              }
            }
          }
          if(piece_amount[0] <= 0){//自分が0
            return -9999;
          }else if(piece_amount[1] <= 0){//相手0
            return 9999;
          }else{//それ以外は普通に評価値を返す
            return eval(open_value,turn,p);
          }
        }else{
          return -1 * run(false,depth - 1, turn * -1 , turn_count, -open_value, -beta, -alpha);
        }
      }
      return alpha;
    }
  }